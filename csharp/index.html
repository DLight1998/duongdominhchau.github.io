<!DOCTYPE html>
<html><head>
	<title>Blog của Châu</title>
	<link rel="stylesheet" href="/css/main.css">
</head>
<body><header>
	<h1><a href="/">Blog của Châu</a></h1>
</header>
<div id="content">
	<h1>C#</h1>
	<p>2020-06-09 01:08:20 &#43;0700 &#43;07</p>
	<h2>Mục lục</h2>
	<nav id="TableOfContents">
  <ul>
    <li><a href="#ngôn-ngữ-lập-trình-c">Ngôn ngữ lập trình C#</a></li>
    <li><a href="#hello-world">Hello world</a></li>
    <li><a href="#câu-lệnh-giá-trị-phép-toán">Câu lệnh, giá trị, phép toán</a></li>
    <li><a href="#kiểu-dữ-liệu-biến">Kiểu dữ liệu, biến</a></li>
    <li><a href="#nhập-xuất-với-console">Nhập xuất với <code>Console</code></a></li>
    <li><a href="#mảng">Mảng</a>
      <ul>
        <li><a href="#khai-báo-và-khởi-tạo">Khai báo và khởi tạo</a></li>
        <li><a href="#duyệt-qua-mảng">Duyệt qua mảng</a></li>
        <li><a href="#sao-chép-nội-dung-mảng">Sao chép nội dung mảng</a></li>
      </ul>
    </li>
    <li><a href="#lớp">Lớp</a>
      <ul>
        <li><a href="#khai-báo-lớp-trường-phương-thức">Khai báo lớp, trường, phương thức</a></li>
        <li><a href="#mức-truy-cập">Mức truy cập</a></li>
        <li><a href="#thuộc-tính">Thuộc tính</a></li>
        <li><a href="#phương-thức-khởi-tạo">Phương thức khởi tạo</a></li>
        <li><a href="#nạp-chồng">Nạp chồng</a></li>
        <li><a href="#this"><code>this</code></a></li>
        <li><a href="#thành-viên-static">Thành viên <code>static</code></a></li>
      </ul>
    </li>
    <li><a href="#kế-thừa">Kế thừa</a>
      <ul>
        <li><a href="#mức-truy-cập-khi-kế-thừa-và-từ-khóa-protected">Mức truy cập khi kế thừa và từ khóa <code>protected</code></a></li>
        <li><a href="#gọi-đến-phương-thức-khởi-tạo-của-lớp-cơ-sở">Gọi đến phương thức khởi tạo của lớp cơ sở</a></li>
        <li><a href="#nạp-chồng-trên-nhiều-lớp">Nạp chồng trên nhiều lớp</a></li>
        <li><a href="#che-phương-thức-kế-thừa-được">Che phương thức kế thừa được</a></li>
        <li><a href="#gọi-phương-thức-ở-lớp-cơ-sở-lại-gặp-base">Gọi phương thức ở lớp cơ sở, lại gặp <code>base</code></a></li>
        <li><a href="#nạp-đè">Nạp đè</a></li>
        <li><a href="#che-phương-thức-ảo">Che phương thức ảo</a></li>
        <li><a href="#abstract"><code>abstract</code>???</a></li>
        <li><a href="#giao-diện-interface-và-đa-kế-thừa">Giao diện (interface) và đa kế thừa</a></li>
      </ul>
    </li>
    <li><a href="#chi-tiết-về-phương-thức">Chi tiết về phương thức</a></li>
    <li><a href="#misc">Misc</a></li>
  </ul>
</nav>
	<h2 id="ngôn-ngữ-lập-trình-c">Ngôn ngữ lập trình C#</h2>
<p>Ngôn ngữ lập trình được dùng để viết chương trình <strong>cho con người có thể đọc</strong>.</p>
<p>C# là ngôn ngữ lập trình bậc cao, tức là code của nó gần với con người hơn,
dễ đọc hiểu hơn. Bậc ở đây không phải chỉ độ mạnh yếu mà là chỉ mức trừu tượng.</p>
<ul>
<li>Ở mức mã máy (thấp nhất) thì chương trình chỉ là một chuỗi bit.</li>
<li>Với hợp ngữ (assembly) thì chương trình là một dãy các chỉ thị cực kỳ đơn giản
như cộng, trừ, nhân chia, chép giá trị từ chỗ này sang chỗ khác, nhảy đến một
địa chỉ và tiếp tục chạy chương trình từ chỗ đó, &hellip;</li>
<li>Những ngôn ngữ lập trình như C hay Pascal thì bắt đầu có các hàm, các kiểu
dữ liệu, các câu lệnh rẽ nhánh, câu lệnh lặp, &hellip; Nhờ mấy cái này mà chương
trình có thể trở nên gần giống với câu văn trong ngôn ngữ tự nhiên, ví dụ như
<code>if answer = correctAnswer then increaseScore</code>.</li>
<li>Vấn đề đọc hiểu đã được giải quyết phần nào nhờ mấy cái tính năng của ngôn ngữ
lập trình thời trước như C hay Pascal, nhưng mà mấy cái ngôn ngữ đó quá đơn giản,
với lại nhiều thứ không có sẵn, nên là có những ngôn ngữ mới hơn ra đời, C# là một
trong số đó. Mấy ngôn ngữ này phức tạp hơn (tại vì có nhiều tính năng hơn), bù lại
là chương trình viết ra sẽ càng gần với ngôn ngữ tự nhiên hơn, ví dụ như bên C# có
thể viết <code>foreach (var item in theList)</code>, bỏ qua chữ <code>var</code> thì nó chính là một câu
tiếng Anh (không hoàn chỉnh nhưng) đúng ngữ pháp: for each item in the list (với mỗi
mục trong danh sách).</li>
</ul>
<p>Máy tính không trực tiếp thực thi chương trình viết bằng C#, để chạy được cần phải
biên dịch (compile) ra dạng mà máy có thể thực thi được. Nếu code không đúng cú pháp
thì lúc biên dịch sẽ gặp lỗi, kêu là lỗi biên dịch (compile error). Nếu chương trình
không có lỗi biên dịch nhưng mà tới lúc chạy gặp lỗi thì lỗi đó kêu là lỗi thực thi
(runtime error, chữ runtime tách ra để đọc hiểu, run là chạy, time là thời điểm,
ghép lại là lỗi lúc chạy).</p>
<h2 id="hello-world">Hello world</h2>
<p>Dưới này là chương trình Hello world viết bằng C#</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#75715e">/* Chương trình bắt đầu chạy từ đây */</span>
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			<span style="color:#75715e">// In ra dòng chữ &#34;Hello world&#34;
</span><span style="color:#75715e"></span>			Console.WriteLine(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;This program is written in C#&#34;</span>);
		}
	}
}
</code></pre></div><p>Tạm bỏ qua dòng <code>using</code> và <code>namespace</code> (sẽ nói cụ thể ở phần <a href="#Namespace">Namespace</a>).</p>
<p>Chương trình trong C# luôn được viết trong một lớp (<code>class</code>, phần này cũng sẽ được nói sau).</p>
<p><code>static void Main()</code> là dòng khai báo một phương thức (method) tĩnh (<code>static</code>) có tên là <code>Main</code>.
Phương thức đặt tên gì cũng được, nhưng mà chương trình luôn bắt đầu chạy từ <code>Main()</code> nên thiếu
nó là không chạy được.</p>
<p>Các câu lệnh sẽ được thực thi theo hướng từ trên xuống.</p>
<p>Phần viết bên trong <code>/*</code> <code>*/</code> hoặc từ <code>//</code> đến hết dòng là chú thích (comment),
sẽ bị bỏ qua khi chạy chương trình. Chú thích dùng để viết <strong>cho con người đọc</strong>,
thường xài để giải thích lý do. Chú thích viết bằng <code>/*</code> <code>*/</code> không lồng nhau.</p>
<p>Các dòng <code>Console.WriteLine</code> trong <code>Main()</code> gọi là câu lệnh. Câu lệnh được dùng
để mô tả một hành động nào đó, ở đây hành động được mô tả là in ra màn hình. Câu
lệnh kết thúc bằng dấu chấm phẩy <code>;</code></p>
<p><code>Console</code> là một lớp có sẵn trong thư viện chuẩn của C#, dùng cho nhập xuất cơ bản
trên giao diện dòng lệnh (mấy cái như <code>cmd</code> hoặc <code>PowerShell</code> của Windows).
<code>WriteLine</code> là một phương thức của lớp <code>Console</code>, xài để in giá trị ra màn hình, sau
khi in xong sẽ in kèm ký tự xuống dòng.</p>
<p>Phần viết bên trong cặp <code>&quot;</code> gọi là chuỗi (string). Cặp dấu <code>&quot;</code> dùng để đánh dấu vị trí
bắt đầu và kết thúc của chuỗi, <code>&quot;abc&quot;</code> là chuỗi chứa 3 ký tự <code>a</code>, <code>b</code> và <code>c</code>, cặp dấu <code>&quot;</code>
chỉ là để đánh dấu vị trí bắt đầu và kết thúc, không phải nội dung của chuỗi.</p>
<h2 id="câu-lệnh-giá-trị-phép-toán">Câu lệnh, giá trị, phép toán</h2>
<p>Câu lệnh để thể hiện một hành động nào đó có tạo ra ảnh hưởng. Ảnh hưởng ở đây có thể là
giá trị trên bộ nhớ được sửa đổi, dữ liệu được gửi đi (ví dụ câu lệnh in ra màn hình) hoặc
nhận về, &hellip;</p>
<p>Giá trị có thể là những thứ đơn giản như <code>1</code> (số nguyên), <code>3.14</code> (số thực), <code>&quot;abc&quot;</code>
(chuỗi), cũng có thể là kết quả của phép tính phức tạp, ví dụ <code>1 + 2 * 3.14 / (3 - 4)</code>.</p>
<p>Mấy cái như cộng, trừ, nhân, chia gọi chung là phép toán hoặc toán tử (operator).
C# xài ký tự <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> cho 4 phép toán này, ngoài ra có thêm <code>%</code> cho phép
chia lấy phần dư. Giá trị tham gia vào phép toán được gọi là toán hạng (operand).
Ví dụ như <code>1 + 2</code> thì <code>+</code> là toán tử còn <code>1</code> với <code>2</code> là toán hạng.</p>
<h2 id="kiểu-dữ-liệu-biến">Kiểu dữ liệu, biến</h2>
<p>Mọi giá trị trong C# đều có kiểu dữ liệu (data type) của nó. Kiểu dữ liệu nó là một
tập hợp các giá trị và các phép toán cho mấy cái giá trị đó. Ví dụ như kiểu <code>byte</code>
(một kiểu số nguyên không âm trong C#) là tập hợp chứa các số từ <code>0</code> tới <code>255</code>, biến
biến thuộc kiểu này có thể chứa số bất kỳ từ <code>0</code> tới <code>255</code>. Kiểu <code>byte</code> cũng có các
phép toán như cộng, trừ, nhân, chia nên nếu có 2 giá trị thuộc kiểu <code>byte</code> có thể cộng
2 giá trị đó để cho ra giá trị mới.</p>
<p>C# có các kiểu dữ liệu cơ bản này:</p>
<ul>
<li>Số nguyên: Được phân ra làm số nguyên có dấu (signed, tức là có thể chứa giá trị âm)
và số nguyên không dấu (không thể chứa giá trị âm). Kiểu số nguyên chủ yếu được dùng là
kiểu <code>int</code>, các kiểu khác có thể xem ở
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types</a></li>
<li>Số thực: Tất cả các kiểu số thực đều là số có dấu (tức là có thể chứa số âm), thường
chỉ dùng <code>float</code> hoặc <code>double</code>. Xem chi tiết ở
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types</a></li>
<li>Boolean: Tên trong C# là <code>bool</code>. Kiểu này chỉ có 2 giá trị là <code>true</code> và <code>false</code>.</li>
<li>Ký tự: Tên kiểu trong C# là <code>char</code>, dùng để chứa một ký tự Unicode (câu này không
hoàn toàn đúng, nhưng mà nếu giải thích rõ ra thì hơi dài nên cứ coi như nó đúng đi).</li>
<li>Chuỗi: Tên kiểu là string, dùng để chứa 0 hoặc nhiều ký tự.</li>
</ul>
<p>Biến (variable) là một vùng trên bộ nhớ được đặt tên, xài để chứa giá trị thuộc một
kiểu nào đó được xác định trước, giá trị của cái vùng nhớ đó có thể thay đổi (cho nên
nó mới được gọi là biến, chữ biến trong biến đổi ấy). Tên biến là để con người đọc
thôi chứ máy nó không quan tâm, nên là chọn tên sao cho có ý nghĩa tí.</p>
<p>Khai báo biến theo cú pháp <code>&lt;kiểu&gt; &lt;tên&gt;;</code> với <code>&lt;kiểu&gt;</code> là tên kiểu dữ liệu, <code>&lt;tên&gt;</code> là
tên biến.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span> paymentPerHour; <span style="color:#75715e">// Biến kiểu số nguyên có dấu, tên là paymentPerHour
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> hoursWorked;
</code></pre></div><p>Lần đầu tiên gán giá trị cho biến được gọi là khởi tạo. Có thể khởi tạo ngay sau khi
khai báo biến luôn:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span> paymentPerHour = <span style="color:#ae81ff">20000</span>;
<span style="color:#66d9ef">int</span> hoursWorked = <span style="color:#ae81ff">80</span>;
</code></pre></div><p>Có thể sử dụng biến với các phép toán mà kiểu của nó có (ví dụ số nguyên có phép toán
cộng, trừ, nhân, chia, chia dư, &hellip;)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span> paymentPerHour = <span style="color:#ae81ff">20000</span>;
<span style="color:#66d9ef">int</span> hoursWorked = <span style="color:#ae81ff">80</span>;
<span style="color:#75715e">// Biến paymentPerHour và hoursWorked thuộc kiểu số nguyên nên có thể nhân
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> wage = paymentPerHour * hoursWorked;
</code></pre></div><h2 id="nhập-xuất-với-console">Nhập xuất với <code>Console</code></h2>
<p>In ra màn hình bằng <code>Console.Write()</code> hoặc <code>Console.WriteLine()</code>.
Write chỉ in giá trị được truyền vào rồi thôi, còn WriteLine sau khi
in giá trị xong sẽ in thêm 1 ký tự xuống dòng.</p>
<p>Viết giá trị muốn in vào trong cặp ngoặc tròn, mỗi lần chỉ được
in 1 giá trị. Muốn in nhiều giá trị thì viết nhiều câu lệnh,
mỗi lần truyền 1 giá trị.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#75715e">// Đoạn chương trình trên in ra `Helloworld` (không có khoảng trắng ở giữa).
</span><span style="color:#75715e">// `Console.Write()` chỉ in cái được truyền vào, không in thêm gì khác.
</span><span style="color:#75715e">// Sau `world` có ký tự xuống dòng do `Console.WriteLine()` in kèm.
</span><span style="color:#75715e"></span>Console.Write(<span style="color:#e6db74">&#34;Hello&#34;</span>);
Console.WriteLine(<span style="color:#e6db74">&#34;world&#34;</span>);
</code></pre></div><p>Đọc 1 dòng từ bàn phím bằng <code>Console.ReadLine()</code>, kết quả được đưa về
dưới dạng chuỗi.</p>
<p>Để chuyển chuỗi đọc được sang kiểu khác, có thể dùng lớp <code>Convert</code>,
lớp này có các phương thức như <code>ToInt32()</code> để chuyển sang kiểu <code>int</code>,
<code>ToDouble()</code> để sang kiểu <code>double</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">string</span> name = Console.ReadLine();
<span style="color:#66d9ef">int</span> age = Convert.ToInt32(Console.ReadLine());
<span style="color:#66d9ef">double</span> weightInKg = Convert.ToDouble(Console.ReadLine());
</code></pre></div><p>Lưu ý là đoạn code trên chỉ đọc vào chứ không in ra, nên lúc chạy sẽ thấy như chương trình
không phản hồi người dùng. Để người dùng biết cần nhập gì, cần in thông báo ra trước:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Console.Write(<span style="color:#e6db74">&#34;Your name: &#34;</span>);
<span style="color:#66d9ef">string</span> name = Console.ReadLine();
Console.Write(<span style="color:#e6db74">&#34;Your age: &#34;</span>);
<span style="color:#66d9ef">int</span> age = Convert.ToInt32(Console.ReadLine());
Console.Write(<span style="color:#e6db74">&#34;Your weight in kg: &#34;</span>);
<span style="color:#66d9ef">double</span> weightInKg = Convert.ToDouble(Console.ReadLine());
Console.WriteLine(<span style="color:#e6db74">&#34;Here is what you entered:&#34;</span>);
Console.Write(<span style="color:#e6db74">&#34;		 Name: &#34;</span>);
Console.WriteLine(name);
Console.Write(<span style="color:#e6db74">&#34;		 Age: &#34;</span>);
Console.WriteLine(age);
Console.Write(<span style="color:#e6db74">&#34;		 Weight: &#34;</span>);
Console.Write(weightInKg);
Console.WriteLine(<span style="color:#e6db74">&#34; kg&#34;</span>);
</code></pre></div><p>In từng giá trị như trên sẽ rất phiền phức, nên <code>Console</code> có cho phép dùng
<code>Write</code> và <code>WriteLine</code> theo một cách khác ngắn gọn hơn:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Console.Write(<span style="color:#e6db74">&#34;Your name: &#34;</span>);
<span style="color:#66d9ef">string</span> name = Console.ReadLine();
Console.Write(<span style="color:#e6db74">&#34;Your age: &#34;</span>);
<span style="color:#66d9ef">int</span> age = Convert.ToInt32(Console.ReadLine());
Console.Write(<span style="color:#e6db74">&#34;Your weight in kg: &#34;</span>);
<span style="color:#66d9ef">double</span> weightInKg = Convert.ToDouble(Console.ReadLine());
Console.WriteLine(<span style="color:#e6db74">&#34;Here is what you entered:&#34;</span>);
Console.WriteLine(<span style="color:#e6db74">&#34;		 Name: {0}&#34;</span>, name);
Console.WriteLine(<span style="color:#e6db74">&#34;		 Age: {0}&#34;</span>, age);
Console.WriteLine(<span style="color:#e6db74">&#34;		 Weight: {0} kg&#34;</span>, weightInKg);
</code></pre></div><p>Chuỗi đầu tiên được gọi là chuỗi định dạng (format string), tức là chuỗi dùng để
mô tả kết quả sau khi in sẽ ra cái gì. Phía sau có thể truyền bao nhiêu giá trị
cũng được, giá trị đầu tiên có số thứ tự là 0 và sẽ được dùng để thế vào <code>{0}</code>
trong chuỗi định dạng. Một giá trị có thể dùng nhiều lần trong chuỗi định dạng:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Console.WriteLine(<span style="color:#e6db74">&#34;{0}{1}{0}&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>); <span style="color:#75715e">// In ra &#34;aba&#34;
</span></code></pre></div><h2 id="mảng">Mảng</h2>
<h3 id="khai-báo-và-khởi-tạo">Khai báo và khởi tạo</h3>
<p>Biến thuộc các kiểu dữ liệu ở phía trước chỉ lưu một giá trị. Khi cần
lưu nhiều giá trị thì không thể cứ khai báo biến cho từng giá trị được,
lúc này cần dùng tới mảng (array).</p>
<p>Kiểu mảng là kiểu có thể chứa nhiều giá trị cùng kiểu dữ liệu. Kích thước
của mảng là cố định khi nó được tạo ra. Các giá trị bên trong mảng gọi là
phần tử (element).</p>
<p>Tên kiểu mảng có dạng <code>T[]</code> với <code>T</code> là tên của kiểu phần tử, ví dụ:
<code>int[]</code> là kiểu mảng với các phần tử là số nguyên.</p>
<p>Không giống với những kiểu đơn giản như <code>int</code> hay <code>float</code>, biến kiểu mảng
không trực tiếp chứa dữ liệu, dữ liệu được lưu ở chỗ khác trên bộ nhớ.
Biến thuộc kiểu mảng chỉ chứa địa chỉ của nơi lưu các phần tử mảng mà thôi.</p>
<p><img src="img/Array.svg" alt="Hình minh họa cho biến thuộc kiểu mảng"></p>
<p>Nhìn hình bên trên có thể thấy, các phần tử của mảng được lưu ở địa chỉ từ
<code>0x1000</code> về sau còn biến <code>arr</code> lại nằm ở địa chỉ <code>0x444</code>.</p>
<p>Để sử dụng mảng, trước hết cần khai báo một biến kiểu mảng để chỉ tới vùng
lưu giá trị các phần tử.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr;
</code></pre></div><p><img src="img/Array-uninitialized.svg" alt="Hình minh họa biến kiểu mảng chưa được khởi tạo"></p>
<p>Sau đó là tạo mảng mới bằng toán tử <code>new</code>, lúc này bộ nhớ sẽ được cấp cho
chương trình để lưu các phần tử của mảng, cho nên trong cặp ngoặc vuông cần
phải có kích thước cụ thể của mảng.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr;
<span style="color:#75715e">// Cấp phát 1 vùng nhớ đủ chứa 4 phần tử kiểu int và cho `arr` trỏ đến
</span><span style="color:#75715e"></span>arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>]; 
</code></pre></div><p><img src="img/Array-new.svg" alt="Hình minh họa biến kiểu mảng sau khi đã khởi tạo"></p>
<p>Có thể kết hợp 2 bước khai báo và khởi tạo lại</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>];
</code></pre></div><p>Đọc/ghi giá trị từng phần tử trong mảng bằng toán tử <code>[]</code>, trong cặp ngoặc vuông
ghi chỉ số (index) của phần tử cần truy cập, phần tử đầu của mảng có chỉ số là <code>0</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>];
arr[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">123</span>;
arr[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">456</span>;
arr[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">789</span>;
arr[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">0</span>;
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p>Khi dùng <code>new</code>, các phần tử của mảng đều được khởi tạo bằng giá trị
mặc định của kiểu, đối với kiểu số thì giá trị mặc định là <code>0</code>, kiểu
<code>bool</code> là <code>false</code>, kiểu đối tượng là <code>null</code>, &hellip; Vậy cho nên dòng
<code>arr[3] = 0</code> bên trên có thể loại bỏ mà không làm thay đổi ý nghĩa
của chương trình.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>];
arr[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">123</span>;
arr[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">456</span>;
arr[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">789</span>;
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p>Có thể khởi tạo giá trị các phần tử ngay khi cấp phát bộ nhớ bằng <code>new</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>] { <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">456</span>, <span style="color:#ae81ff">789</span>, <span style="color:#ae81ff">0</span> };
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p>Nếu trong cặp ngoặc nhọn có đủ giá trị cho tất cả các phần tử đều thì
có thể bỏ trống kích thước mảng, trình biên dịch nó tự biết đếm số phần
tử trong cặp ngoặc nhọn.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#75715e">// arr vẫn là mảng 4 phần tử
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[] { <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">456</span>, <span style="color:#ae81ff">789</span>, <span style="color:#ae81ff">0</span> };
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p><code>new int[] { 123, 456, 789, 0 }</code> tạo một mảng và khởi tạo cho các phần tử
của nó bằng những giá trị được ghi trong cặp ngoặc nhọn.</p>
<p>Nếu khởi tạo giá trị các phần tử của mảng ngay khi khai báo biến kiểu mảng thì
có thể bỏ qua <code>new</code> luôn</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">456</span>, <span style="color:#ae81ff">789</span>, <span style="color:#ae81ff">0</span> };
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p>Trong trường hợp biến đã được khai báo trước đó thì không bỏ <code>new</code> được</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr;
<span style="color:#75715e">// Nếu viết như dòng này sẽ bị lỗi biên dịch
</span><span style="color:#75715e">// arr = { 123, 456, 789, 0 }; 
</span><span style="color:#75715e"></span>arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[] { <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">456</span>, <span style="color:#ae81ff">789</span>, <span style="color:#ae81ff">0</span> };
Console.WriteLine(<span style="color:#e6db74">&#34;{0} {1} {2} {3}&#34;</span>, arr[<span style="color:#ae81ff">0</span>], arr[<span style="color:#ae81ff">1</span>], arr[<span style="color:#ae81ff">2</span>], arr[<span style="color:#ae81ff">3</span>]);
</code></pre></div><p>Lưu ý là trong trường hợp không khởi tạo tất cả phần tử trong mảng thì không thể
bỏ qua kích thước mảng, nếu không sẽ làm thay đổi ý nghĩa chương trình.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr1 = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>] { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> }; <span style="color:#75715e">// Mảng 4 phần tử 1, 2, 3, 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>[] arr2 = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[] { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> }; <span style="color:#75715e">// Mảng 3 phần tử 1, 2, 3
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>[] arr3 = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> }; <span style="color:#75715e">// Như trên, mảng 3 phần tử 1, 2, 3
</span></code></pre></div><h3 id="duyệt-qua-mảng">Duyệt qua mảng</h3>
<p>Kích thước của mảng (số phần tử) được lưu trong thuộc tính (property) <code>Length</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>];
Console.WriteLine(<span style="color:#e6db74">&#34;Length of arr = {0}&#34;</span>, arr.Length);
</code></pre></div><p>Có thể dùng <code>foreach</code> để duyệt qua từng phần tử trong mảng, hoặc dùng <code>for</code> với
biến lặp duyệt qua từng chỉ số (index) của mảng, sau đó dùng biến lặp (đang chứa
chỉ số phần tử mảng) để truy cập phần tử trong mảng.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
<span style="color:#75715e">// Duyệt qua mảng bằng vòng lặp for, chỉ số của
</span><span style="color:#75715e">// phần tử hiện tại được lưu trong biến i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; arr.Length; ++i)
{
	Console.WriteLine(arr[i]);
}
<span style="color:#75715e">// Duyệt qua mảng bằng vòng lặp foreach, không có
</span><span style="color:#75715e">// chỉ số của phần tử hiện tại không được lưu
</span><span style="color:#75715e"></span><span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> arr)
{
	Console.WriteLine(<span style="color:#66d9ef">value</span>);
}
</code></pre></div><p><code>foreach</code> sẽ lần lượt lấy từng giá trị trong mảng gán cho biến tạm rồi
thực thi đoạn code trong thân vòng lặp.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
<span style="color:#75715e">/*
</span><span style="color:#75715e">Vòng lặp foreach bên dưới tương tự với đoạn code này:
</span><span style="color:#75715e">
</span><span style="color:#75715e">int value;
</span><span style="color:#75715e">value = arr[0];
</span><span style="color:#75715e">Console.WriteLine(value);
</span><span style="color:#75715e">value = arr[1];
</span><span style="color:#75715e">Console.WriteLine(value);
</span><span style="color:#75715e">value = arr[2];
</span><span style="color:#75715e">Console.WriteLine(value);
</span><span style="color:#75715e">value = arr[3];
</span><span style="color:#75715e">Console.WriteLine(value);
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> arr)
{
	Console.WriteLine(<span style="color:#66d9ef">value</span>);
}
</code></pre></div><h3 id="sao-chép-nội-dung-mảng">Sao chép nội dung mảng</h3>
<p>Biến kiểu mảng chỉ chứa địa chỉ của nơi lưu các phần tử trên bộ nhớ,
cho nên không thể sao chép mảng bằng phép gán.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
<span style="color:#66d9ef">int</span>[] anotherArray = arr;
arr[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">0</span>;
Console.WriteLine(anotherArray[<span style="color:#ae81ff">0</span>]); <span style="color:#75715e">// In ra 0 chứ không phải 1
</span></code></pre></div><p><img src="img/Array-assign.svg" alt="Hình minh họa kết quả phép gán của biến kiểu mảng"></p>
<p>Để chép nội dung mảng cần tạo mảng mới trước rồi chép giá trị từng phần tử sang.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
<span style="color:#66d9ef">int</span>[] anotherArray = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[arr.Length];
<span style="color:#75715e">// Đây là một trường hợp không thể dùng foreach, tại vì
</span><span style="color:#75715e">// mình cần sử dụng giá trị của chỉ số hiện tại.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; arr.Length; ++i) {
	anotherArray[i] = arr[i];
}
arr[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">0</span>;
Console.WriteLine(anotherArray[<span style="color:#ae81ff">0</span>]); <span style="color:#75715e">// Lúc này in ra 1
</span></code></pre></div><p><img src="img/Array-copy.svg" alt="Hình minh họa việc sao chép mảng"></p>
<p>Bởi vì việc sao chép nội dung mảng rất thường gặp nên C# có cung cấp sẵn
phương thức cho việc sao chép trong lớp <code>Array</code> (một lớp chứa các phương
thức giúp thao tác với mảng tiện lợi hơn).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">int</span>[] arr = { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
<span style="color:#66d9ef">int</span>[] anotherArray = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[arr.Length];
<span style="color:#75715e">// Mảng nguồn, mảng đích, số phần tử cần chép
</span><span style="color:#75715e"></span>Array.Copy(arr, anotherArray, arr.Length);

<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> anotherArray)
{
	Console.WriteLine(<span style="color:#66d9ef">value</span>);
}
</code></pre></div><h2 id="lớp">Lớp</h2>
<p>Chỉ sử dụng các kiểu cơ bản như <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code> không đủ để
viết ra code dễ đọc. Lấy ví dụ như đoạn chương trình nhập 2 điểm và in ra
khoảng cách giữa 2 điểm vừa nhập</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Console.WriteLine(<span style="color:#e6db74">&#34;Nhập tọa độ điểm thứ nhất: &#34;</span>);
<span style="color:#66d9ef">double</span> x1 = Convert.ToDouble(Console.ReadLine());
<span style="color:#66d9ef">double</span> y1 = Convert.ToDouble(Console.ReadLine());

Console.WriteLine(<span style="color:#e6db74">&#34;Nhập tọa độ điểm thứ hai: &#34;</span>);
<span style="color:#66d9ef">double</span> x2 = Convert.ToDouble(Console.ReadLine());
<span style="color:#66d9ef">double</span> y2 = Convert.ToDouble(Console.ReadLine());

<span style="color:#66d9ef">double</span> distance = Math.Sqrt(Math.Pow(x2 - x1, <span style="color:#ae81ff">2</span>) + Math.Pow(y2 - y1, <span style="color:#ae81ff">2</span>));
Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm vừa nhập là {0}&#34;</span>, distance);
</code></pre></div><p>Ở đoạn code trên, mỗi khi cần lưu 1 điểm cần khai báo 2 biến. Bởi vì phải
khai báo nhiều biến hơn nên tên được dùng cho biến cũng trở nên xấu xí khó
đọc hơn. Thêm nữa là phần tính toán khoảng cách bị lẫn vào trong code làm
cho nó không thể được sử dụng lại ở nơi khác (trừ khi copy-paste code).</p>
<p>Theo OOP, chương trình được mô tả theo các đối tượng (object). Đối tượng có
được tạo ra theo một hình mẫu cụ thể, gọi là lớp (class). Đối tượng có các
phương thức (method) để mô tả hành động, thuộc tính (property) để mô tả
những dữ liệu được công khai, và trường (field) cho những dữ liệu mà đối
tượng không cần công khai.</p>
<h3 id="khai-báo-lớp-trường-phương-thức">Khai báo lớp, trường, phương thức</h3>
<p>Để sử dụng đối tượng cần khai báo lớp, sử dụng từ khóa <code>class</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
}
</code></pre></div><p>Trong class có thể có trường (field), cách khai báo giống với khai báo biến.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
	<span style="color:#66d9ef">double</span> x;
	<span style="color:#66d9ef">double</span> y;
}
</code></pre></div><p>Trong class cũng có thể có phương thức (method), khai báo theo cú pháp
<code>&lt;kiểu trả về&gt; &lt;tên&gt;(&lt;các tham số&gt;)</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
	<span style="color:#66d9ef">double</span> x;
	<span style="color:#66d9ef">double</span> y;
	<span style="color:#66d9ef">double</span> Distance(Point other)
	{
		<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(x - other.x, <span style="color:#ae81ff">2</span>), Math.Pow(y - other.y, <span style="color:#ae81ff">2</span>));
	}
}
</code></pre></div><p>Tạo object bằng <code>new</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
	{
		<span style="color:#66d9ef">double</span> x;
		<span style="color:#66d9ef">double</span> y;
		<span style="color:#66d9ef">double</span> Distance(Point other)
		{
			<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(x - other.x, <span style="color:#ae81ff">2</span>), Math.Pow(y - other.y, <span style="color:#ae81ff">2</span>));
		}
	}

	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#66d9ef">static</span> Point ReadFromConsole(<span style="color:#66d9ef">string</span> message)
		{
			Console.WriteLine(message);
			Point pt = <span style="color:#66d9ef">new</span> Point(); <span style="color:#75715e">// Tạo đối tượng thuộc kiểu Point
</span><span style="color:#75715e"></span>			Console.Write(<span style="color:#e6db74">&#34;Nhập x: &#34;</span>);
			pt.x = Convert.ToDouble(Console.ReadLine());
			Console.Write(<span style="color:#e6db74">&#34;Nhập y: &#34;</span>);
			pt.y = Convert.ToDouble(Console.ReadLine());
			<span style="color:#66d9ef">return</span> pt;
		}
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Point firstPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ nhất:&#34;</span>);
			Point secondPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ hai:&#34;</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm vừa nhập là {0}&#34;</span>,
					firstPoint.Distance(secondPoint));
		}
	}
}
</code></pre></div><p>Để tính khoảng cách của 2 điểm cần làm 3 việc:</p>
<ul>
<li>Đọc vào điểm thứ nhất</li>
<li>Đọc vào điểm thứ hai</li>
<li>Tính và in ra khoảng cách</li>
</ul>
<p>Chương trình lúc này dài hơn chương trình ban đầu, nhưng phần xử lý việc nhập
2 điểm và tính khoảng cách trở thành</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Point firstPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ nhất:&#34;</span>);
Point secondPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ hai:&#34;</span>);
Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm vừa nhập là {0}&#34;</span>,
		firstPoint.Distance(secondPoint));
</code></pre></div><p>Nếu để ý kỹ sẽ thấy mỗi câu lệnh bên trên tương ứng với một hành động
được mô tả bằng lời trước đó.</p>
<h3 id="mức-truy-cập">Mức truy cập</h3>
<p>Các thành viên của một lớp có thể được khai báo 1 trong 3 mức truy cập
<code>public</code>, <code>protected</code>, <code>private</code>. Khai báo <code>public</code> sẽ cho phép truy cập
thành viên đó ở bất cứ đâu. Ngược lại, khai báo <code>private</code> sẽ chỉ cho phép
truy cập trong chính lớp đó. Từ khóa này được thêm trước kiểu dữ liệu.</p>
<p>Thông thường trường (field) sẽ được khai báo <code>private</code>, còn thuộc tính (property)
và phương thức (method) thì được khai báo <code>public</code>. Nếu một phương thức chỉ được
dùng bên trong lớp thì có thể khai báo <code>private</code>.</p>
<p>Chương trình lúc này sẽ ra như bên dưới, chỉ có một vấn đề: không biên dịch được.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
	{
		<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> x;
		<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> y;
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Distance(Point other)
		{
			<span style="color:#75715e">// Ở đây vẫn đang trong class Point nên có thể truy cập x và y của Point
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(x - other.x, <span style="color:#ae81ff">2</span>), Math.Pow(y - other.y, <span style="color:#ae81ff">2</span>));
		}
	}

	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#75715e">// Phương thức này chỉ được dùng trong lớp Program
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// nên có thể khai báo private
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Point ReadFromConsole(<span style="color:#66d9ef">string</span> message)
		{
			Console.WriteLine(message);
			Point pt = <span style="color:#66d9ef">new</span> Point();
			Console.Write(<span style="color:#e6db74">&#34;Nhập x: &#34;</span>);
			<span style="color:#75715e">// Lỗi: x được khai báo private
</span><span style="color:#75715e"></span>			pt.x = Convert.ToDouble(Console.ReadLine());
			Console.Write(<span style="color:#e6db74">&#34;Nhập y: &#34;</span>);
			<span style="color:#75715e">// Lỗi: y được khai báo private
</span><span style="color:#75715e"></span>			pt.y = Convert.ToDouble(Console.ReadLine());
			<span style="color:#66d9ef">return</span> pt;
		}
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Point firstPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ nhất:&#34;</span>);
			Point secondPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ hai:&#34;</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm vừa nhập là {0}&#34;</span>,
					firstPoint.Distance(secondPoint));
		}
	}
}
</code></pre></div><h3 id="thuộc-tính">Thuộc tính</h3>
<p>Đoạn code ở phần trước sẽ gây ra lỗi biên dịch. Ngoại trừ tham gia vào tính toán
bên trong lớp, <code>x</code> và <code>y</code> cũng cần cho bên ngoài truy cập để lớp này có ích.
Trong trường hợp này C# cung cấp một tính năng khác phù hợp hơn trường (field),
đó là thuộc tính (property). Thuộc tính có thể được sử dụng tương tự như trường,
nhưng có thể định nghĩa getter (phương thức được dùng khi property được đọc)
và setter (phương thức được dùng khi property được ghi).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Integer</span>
	{
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span>; <span style="color:#75715e">// public field
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// public property với getter và setter mặc định.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Cái này không khác gì public field
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Value
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#75715e">// public property với getter tự định nghĩa, không có setter
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> One
		{
			<span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; }
		}

		<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> _nonnegativeValue;
		<span style="color:#75715e">// public property với setter tự định nghĩa
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Thường thì tự định nghĩa setter cần một private field để
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// lưu giá trị của nó, đồng thời cũng cần phải định nghĩa
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// getter để lấy giá trị đó ra
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> NonnegativeValue
		{
			<span style="color:#66d9ef">get</span>
			{
				<span style="color:#66d9ef">return</span> _nonnegativeValue;
			}
			<span style="color:#66d9ef">set</span>
			{
				<span style="color:#75715e">// `value` là giá trị nằm bên phải dấu = trong phép gán
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> &lt; <span style="color:#ae81ff">0</span>)
				{
					_nonnegativeValue = <span style="color:#ae81ff">0</span>;
				}
				<span style="color:#66d9ef">else</span>
				{
					_nonnegativeValue = <span style="color:#66d9ef">value</span>;
				}
			}
		}

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Integer i = <span style="color:#66d9ef">new</span> Integer();
			i.<span style="color:#66d9ef">value</span> = -<span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Sửa giá trị của trường (field) value
</span><span style="color:#75715e"></span>			i.Value = -<span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Sửa giá trị của thuộc tính (property) Value
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// Dòng này sẽ gây ra lỗi biên dịch, thuộc tính này
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// không có setter nên không thể sửa giá trị của nó.
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// i.One = 2; 
</span><span style="color:#75715e"></span>			i.NonnegativeValue = -<span style="color:#ae81ff">123</span>;
			Console.WriteLine(i.NonnegativeValue); <span style="color:#75715e">// In ra 0
</span><span style="color:#75715e"></span>			i.NonnegativeValue = <span style="color:#ae81ff">123</span>;
			Console.WriteLine(i.NonnegativeValue); <span style="color:#75715e">// In ra 123
</span><span style="color:#75715e"></span>		}
	}
}
</code></pre></div><p>Sử dụng thuộc tính, đoạn code trên có thể sửa thành</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
	{
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> X {
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Y
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Distance(Point other)
		{
			<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(X - other.X, <span style="color:#ae81ff">2</span>), Math.Pow(Y - other.Y, <span style="color:#ae81ff">2</span>));
		}
	}

	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Point ReadFromConsole(<span style="color:#66d9ef">string</span> message)
		{
			Console.WriteLine(message);
			Point pt = <span style="color:#66d9ef">new</span> Point();
			Console.Write(<span style="color:#e6db74">&#34;Nhập x: &#34;</span>);
			pt.X = Convert.ToDouble(Console.ReadLine());
			Console.Write(<span style="color:#e6db74">&#34;Nhập y: &#34;</span>);
			pt.Y = Convert.ToDouble(Console.ReadLine());
			<span style="color:#66d9ef">return</span> pt;
		}
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Point firstPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ nhất:&#34;</span>);
			Point secondPoint = ReadFromConsole(<span style="color:#e6db74">&#34;Nhập thông tin điểm thứ hai:&#34;</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm vừa nhập là {0}&#34;</span>,
					firstPoint.Distance(secondPoint));
		}
	}
}
</code></pre></div><h3 id="phương-thức-khởi-tạo">Phương thức khởi tạo</h3>
<p>Với những gì đã biết đến hiện tại, để tạo một đối tượng thể hiện cho điểm (1,2)
<code>Point</code> cần phải viết</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Point pt = <span style="color:#66d9ef">new</span> Point();
pt.X = <span style="color:#ae81ff">1</span>;
pt.Y = <span style="color:#ae81ff">2</span>;
</code></pre></div><p>Khởi tạo từng thành viên trong đối tượng theo cách này rất dễ bỏ sót thành viên.
Hơn nữa phần code khởi tạo sẽ bị rải ra khắp nơi, khi cần thay đổi sẽ phải tìm
tới từng chỗ để sửa. Để giải quyết vấn đề này, C# có phương thức khởi tạo (constructor),
phương thức này <strong>trùng tên với lớp</strong> và <strong>không ghi kiểu trả về</strong>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> X;
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Y;
	<span style="color:#75715e">// Constructor cho lớp Point
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> Point(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">double</span> y)
	{
		X = x;
		Y = y;
	}
	<span style="color:#75715e">// Không phải constructor, vì có ghi kiểu trả về (void)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Point()
	{
	}
}
</code></pre></div><p>Phương thức khởi tạo sẽ được gọi khi dùng <code>new</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Hello</span>
	{
		<span style="color:#66d9ef">public</span> Hello(<span style="color:#66d9ef">string</span> name = <span style="color:#e6db74">&#34;world&#34;</span>)
		{
			Console.WriteLine(<span style="color:#e6db74">&#34;Hello {0}&#34;</span>, name);
		}
	}

	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			<span style="color:#66d9ef">new</span> Hello();
			<span style="color:#66d9ef">new</span> Hello(<span style="color:#e6db74">&#34;everybody&#34;</span>);
		}
	}
}
</code></pre></div><h3 id="nạp-chồng">Nạp chồng</h3>
<p>Phía trên đã giới thiệu về phương thức khởi tạo. Tuy nhiên, một đối tượng thông
thường có thể được khởi tạo theo nhiều cách khác nhau tùy theo dữ liệu của nó,
một phương thức khởi tạo là không đủ để đáp ứng nhiều trường hợp sử dụng.</p>
<p>C# cho phép định nghĩa nhiều phương thức cùng tên nhau nhưng khác về dấu hiệu
(signature), việc định nghĩa nhiều phương thức với cùng một tên như vầy gọi là
nạp chồng (overload). Dấu hiệu của phương thức bao gồm tên phương thức, số lượng
tham số và kiểu của từng tham số, <strong>kiểu trả về không dùng làm dấu hiệu</strong>, cho
nên không thể định nghĩa 2 phương thức giống y nhau chỉ khác kiểu trả về được.</p>
<p>Đoạn chương trình dưới này cho ra cùng kết quả với đoạn phía trên, nhưng lần
này không dùng giá trị mặc định cho tham số nữa mà dùng nạp chồng.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Hello</span>
	{
		<span style="color:#75715e">// Dấu hiệu của hàm này là `Hello()`
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">public</span> Hello()
		{
			Console.WriteLine(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
		}
		<span style="color:#75715e">// Dấu hiệu của hàm này là `(string)`, `()` với `(string)`
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// khác nhau nên nạp chồng được
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">public</span> Hello(<span style="color:#66d9ef">string</span> name)
		{
			Console.WriteLine(<span style="color:#e6db74">&#34;Hello {0}&#34;</span>, name);
		}
	}

	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
	{
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			<span style="color:#66d9ef">new</span> Hello();
			<span style="color:#66d9ef">new</span> Hello(<span style="color:#e6db74">&#34;everybody&#34;</span>);
		}
	}
}
</code></pre></div><h3 id="this"><code>this</code></h3>
<p>Đối tượng có những hành động (thể hiện trong code qua phương thức) và những
đặc tính (thể hiện trong code dưới dạng các trường và thuộc tính). Những
phương thức thông thường cần có đối tượng mới có thể gọi, ví dụ như trong
lớp <code>Point</code> dưới đây, phương thức <code>Distance</code> cần</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
	{
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> X
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Y
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> Point(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">double</span> y)
		{
			X = x;
			Y = y;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Distance(Point other)
		{
			<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(X - other.X, <span style="color:#ae81ff">2</span>) + Math.Pow(Y - other.Y, <span style="color:#ae81ff">2</span>));
		}

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Point pt1 = <span style="color:#66d9ef">new</span> Point(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
			Point pt2 = <span style="color:#66d9ef">new</span> Point(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm là {0}&#34;</span>, pt1.Distance(pt2));
		}
	}
}
</code></pre></div><p>Trong đoạn code trên đối tượng <code>pt1</code> được dùng để gọi phương thức <code>Distance()</code>.
Bên trong phương thức <code>Distance</code> có một giá trị đặc biệt gọi là <code>this</code>, để chỉ
đến đối tượng được dùng khi gọi phương thức này lên. Để cho tiện C# không bắt
buộc phải ghi rõ <code>this.X</code> để chỉ thuộc tính X của đối tượng hiện tại, chỉ cần
ghi <code>X</code> là nó tự hiểu &ldquo;truy cập <code>X</code> của đối tượng hiện tại&rdquo;. Đoạn code trên
có thể viết lại như sau:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">namespace</span> Application
{
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
	{
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> X
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Y
		{
			<span style="color:#66d9ef">get</span>;
			<span style="color:#66d9ef">set</span>;
		}
		<span style="color:#66d9ef">public</span> Point(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">double</span> y)
		{
			<span style="color:#66d9ef">this</span>.X = x;
			<span style="color:#66d9ef">this</span>.Y = y;
		}
		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Distance(Point other)
		{
			<span style="color:#66d9ef">return</span> Math.Sqrt(Math.Pow(<span style="color:#66d9ef">this</span>.X - other.X, <span style="color:#ae81ff">2</span>) + Math.Pow(<span style="color:#66d9ef">this</span>.Y - other.Y, <span style="color:#ae81ff">2</span>));
		}

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
		{
			Point pt1 = <span style="color:#66d9ef">new</span> Point(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
			Point pt2 = <span style="color:#66d9ef">new</span> Point(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
			Console.WriteLine(<span style="color:#e6db74">&#34;Khoảng cách giữa 2 điểm là {0}&#34;</span>, pt1.Distance(pt2));
		}
	}
}
</code></pre></div><p>Tuy nhiên, cách viết này quá dài dòng mà không có ích lợi gì, nên là nếu
được cứ tránh. Viết trực tiếp <code>X</code> là được rồi, không cần <code>this.X</code>.</p>
<p>Ngoài ra <code>this</code> còn dùng trong một trường hợp khác nữa. Xem đoạn code dưới đây:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> width;
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> height;
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> title;
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">public</span> Window(<span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		<span style="color:#66d9ef">this</span>.width = width;
		<span style="color:#66d9ef">this</span>.height = height;
	}
	<span style="color:#66d9ef">public</span> Window(<span style="color:#66d9ef">string</span> title, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		<span style="color:#66d9ef">this</span>.width = width;
		<span style="color:#66d9ef">this</span>.height = height;
		<span style="color:#66d9ef">this</span>.title = title;
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Trong đoạn code trên, phần khởi tạo của 2 trường <code>width</code> và <code>height</code> bị
lặp lại trong mỗi phương thức khởi tạo. Đối với phương thức thông thường
thì để tránh lặp lại có thể đưa phần code chung ra một phương thức mới
rồi gọi tới. Cái đó là cho phương thức thông thường, còn với phương thức
khởi tạo thì cần viết khác đi:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> width;
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> height;
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> title;
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">public</span> Window(<span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		<span style="color:#66d9ef">this</span>.width = width;
		<span style="color:#66d9ef">this</span>.height = height;
	}
	<span style="color:#66d9ef">public</span> Window(<span style="color:#66d9ef">string</span> title, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height): <span style="color:#66d9ef">this</span>(width, height)
	{
		<span style="color:#66d9ef">this</span>.title = title;
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>this()</code> ở đây không phải chỉ tới đối tượng hiện tại nữa, mà được xài như
là tên phương thức khởi tạo của lớp hiện tại, còn cái nào được chọn để chạy
sẽ phụ thuộc vào danh sách tham số.</p>
<p>Về nguồn gốc, cách viết này (thêm dấu hai chấm rồi ghi <code>this(...)</code>
thay vì viết bên trong thân phương thức khởi tạo) bắt nguồn từ C++.
C# quyết định đơn giản hóa nó rồi giữ lại xài luôn. Bên dưới là đoạn
code ở trên được viết lại bằng C++</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> width;
	<span style="color:#66d9ef">int</span> height;
	std<span style="color:#f92672">::</span>string title;
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Window(<span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>width <span style="color:#f92672">=</span> width;
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> height;
	}
	Window(std<span style="color:#f92672">::</span>string title, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height) <span style="color:#f92672">:</span> Window(width, height)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>title <span style="color:#f92672">=</span> title;
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};
</code></pre></div><p>Bên C++ có 2 cách để khởi tạo giá trị của thành viên trong lớp. Cách thứ nhất
là cách được dùng với phương thức khởi tạo 2 tham số trong đoạn code trên,
tức là viết các câu lệnh gán trong thân của phương thức khởi tạo. Cách thứ hai
là viết dấu hai chấm ngay sau phần khai báo của phương thức khởi tạo, sau đó
khởi tạo cho các thành viên theo cú pháp <code>&lt;thành viên&gt;(&lt;giá trị&gt;)</code>. Để gọi tới
phương thức khởi tạo khác thì dùng tên lớp. Bởi vì viết như vầy thì đổi tên lớp
là phải sửa lại nên C# không chọn dùng tên lớp mà chọn <code>this</code>, vậy nên trong C++
viết <code>Window(width, height)</code> còn bên C# thì viết <code>this(width, height)</code>.</p>
<h3 id="thành-viên-static">Thành viên <code>static</code></h3>
<p><code>this</code> trỏ tới đối tượng gọi phương thức lên, vậy trong <code>Main()</code> thì <code>this</code> trỏ tới đâu?
Câu trả lời là: <code>Main()</code> không có <code>this</code>. Những phương thức như <code>Main()</code> có thể được
gọi lên để thực thi luôn mà không cần đối tượng. Những phương thức như vậy được khai báo
bằng từ khóa <code>static</code>, khi truy cập thì dùng tên lớp thay vì một đối tượng nào đó.</p>
<p>Phương thức <code>static</code> không có <code>this</code> nên nó không thể gọi tới phương thức không có khai báo
<code>static</code>. Xem đoạn code dưới này:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cls</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Method1()
	{
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Method2()
	{
		Method1();
	}
}
</code></pre></div><p>Dòng gọi đến phương thức <code>Method1()</code> C# hiểu ngầm là <code>this.Method1()</code>. Nếu như <code>Method2()</code>
được khai báo <code>static</code> thì nó không có <code>this</code>, mà không có <code>this</code> thì làm sao thực hiện
<code>this.Method1()</code> được? Vậy nên phương thức đã được khai báo <code>static</code> thì chỉ có thể truy
cập những thành viên <code>static</code> khác thôi chứ không đụng chạm gì được tới mấy thành viên
không có khai báo <code>static</code>.</p>
<p>Còn về tại sao <code>static</code> (tĩnh) lại được dùng thay vì một từ nào khác có ý nghĩa hơn thì
như vầy: bên C nó xài từ khóa <code>static</code> cho nhiều mục đích khác nhau, C++ thấy nó xài với
nhiều ý nghĩa khác nhau sẵn rồi (ý là nát sẵn rồi thì còn ngại gì nữa) nên vác ra gắn thêm
cho nó cái ý nghĩa nữa (cái ý nghĩa mới của <code>static</code> được C++ thêm vào là cái vừa mô tả ở
trên: thành viên <code>static</code> là thành viên thuộc về lớp, không cần đối tượng cũng truy cập
được), Java với C# lại rẽ ra từ C++ nên từ khóa <code>static</code> cũng theo đó mà chạy qua, thế là
có cái từ khóa dịch ra thấy chả liên quan gì với chức năng của nó.</p>
<p>Vậy <code>static</code> xài để làm gì được? Trước hết là, bên C# không có hàm, chỉ có phương thức,
mà phương thức thông thường thì lúc gọi lên phải có đối tượng. Để có thể khai báo phương
thức giống như hàm trong mấy ngôn ngữ lập trình khác thì phải thêm static vô phương thức.
Ví dụ cho trường hợp này thì có rất nhiều, mấy đoạn code trước đó cũng có xài tới vài cái:
<code>Sqrt</code> (tính căn bậc hai) hay <code>Pow</code> (tính lũy thừa) trong lớp <code>Math</code>, hoặc lùi về trước
nữa thì có <code>Write</code> với <code>WriteLine</code> của lớp <code>Console</code>, mấy cái đó đều là <code>static</code>.</p>
<p>Còn làm gì được với nó nữa? Xem đoạn code dưới đây</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rectangle</span> <span style="color:#75715e">// Hình chữ nhật
</span><span style="color:#75715e"></span>{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Left
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Top
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Width
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Height
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}

	<span style="color:#75715e">// Constructor nhận tọa độ góc trên bên trái với góc dưới bên phải
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> Rectangle(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> top, <span style="color:#66d9ef">int</span> right, <span style="color:#66d9ef">int</span> bottom)
	{
		Left = left;
		Top = top;
		Width = right - left;
		Height = bottom - top;
	}
	<span style="color:#75715e">// Constructor nhận tọa độ góc trên bên trái và kích thước
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> Rectangle(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> top, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		Left = left;
		Top = top;
		Width = width;
		Height = height;
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Lớp <code>Rectangle</code> (hình chữ nhật) ở trên có thể khởi tạo bằng cách đưa vào tọa độ
góc trên bên trái và tọa độ góc dưới bên phải của hình chữ nhật, cũng có thể tạo
bằng cách nhận góc trên bên trái và kích thước của hình. Vấn đề ở đây là, tên tham
số không nằm trong dấu hiệu của phương thức, nên là 2 phương thức khởi tạo ở trên
trùng dấu hiệu với nhau, thành ra không nạp chồng được.</p>
<p>Vậy <code>static</code> giúp ích gì được trong trường hợp này? Xem đoạn code được viết lại</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rectangle</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Left
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Top
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Width
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Height
	{
		<span style="color:#66d9ef">get</span>;
		<span style="color:#66d9ef">set</span>;
	}

	<span style="color:#75715e">// Khai báo phương thức khởi tạo với từ khóa private để bên ngoài
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// lớp này không thể tạo đối tượng được nữa.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">private</span> Rectangle()
	{
	}
	<span style="color:#75715e">// Tạo hình chữ nhật từ tọa độ góc trên bên trái với góc dưới bên phải
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> Rectangle fromPointPair(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> top, <span style="color:#66d9ef">int</span> right, <span style="color:#66d9ef">int</span> bottom)
	{
		<span style="color:#75715e">// Khai báo private chỉ chặn bên ngoài truy cập, phương thức `static`
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// này nằm chung lớp nên vẫn gọi tới được
</span><span style="color:#75715e"></span>		Rectangle rect = <span style="color:#66d9ef">new</span> Rectangle();
		rect.Left = left;
		rect.Top = top;
		rect.Width = right - left;
		rect.Height = bottom - top;
		<span style="color:#66d9ef">return</span> rect;
	}
	<span style="color:#75715e">// Tạo hình chữ nhật từ tọa độ góc trên bên trái và kích thước
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Rectangle fromPointAndSize(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> top, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
	{
		Rectangle rect = <span style="color:#66d9ef">new</span> Rectangle();
		rect.Left = left;
		rect.Top = top;
		rect.Width = width;
		rect.Height = height;
		<span style="color:#66d9ef">return</span> rect;
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Khi viết như ở trên thì lúc dùng lớp <code>Rectangle</code> cũng sẽ viết khác đi,
không còn cần <code>new</code> nữa.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">Rectangle firstRect = Rectangle.fromPointPair(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">11</span>);
Rectangle secondRect = Rectangle.fromPointAndSize(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</code></pre></div><p>Dựa theo định nghĩa của constructor trong C# thì 2 phương thức ở trên không thể
gọi là phương thức khởi tạo được, tại vì nó sai hết cả 2 yêu cầu (tên không giống
tên lớp, lại có kiểu trả về). Tuy nhiên, vì nó được sử dụng để tạo ra đối tượng,
mà nó lại có thể được đặt tên tùy ý nên người ta gọi nó là phương thức khởi tạo
có tên (named constructor). Cách viết này rất phổ biến, và thường được ưu tiên
hơn vì nó có thể được đặt tên mô tả chức năng của nó, chứ không bắt buộc phải
dùng tên lớp nữa.</p>
<h2 id="kế-thừa">Kế thừa</h2>
<p>Lớp trong C# có thể kế thừa lớp khác để thừa hưởng tất cả các thành viên từ lớp đó.
Lúc này lớp được kế thừa sẽ được gọi là lớp cơ sở (base class) và lớp kế thừa gọi là
lớp dẫn xuất (derived class). Ngoài cách gọi này vẫn có những cách gọi khác, như ở
nước mình hay kêu là lớp con (child class) với lớp cha (parent class), thích gọi sao
thì gọi nhưng mà trong bài viết này sẽ chỉ sử dụng cách gọi lớp cơ sở – lớp kế thừa.</p>
<p>Cú pháp để kế thừa cũng khá đơn giản: Thêm dấu hai chấm sau tên lớp rồi ghi tên lớp
cơ sở để kế thừa.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#75715e">// Widget là từ để chỉ chung mấy cái thành phần trên giao diện,
</span><span style="color:#75715e">// ví dụ như button, checkbox, text box, list view, ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> id = -<span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Widget.Draw()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget <span style="color:#75715e">// Lớp Button kế thừa lớp Widget
</span><span style="color:#75715e"></span>{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Click()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Button.Click&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		Console.WriteLine(button.id); <span style="color:#75715e">// In ra -1
</span><span style="color:#75715e"></span>		button.Draw(); <span style="color:#75715e">// In ra &#34;Widget.Draw()&#34;
</span><span style="color:#75715e"></span>		button.Click();
	}
}
</code></pre></div><p>Lớp <code>Button</code> không có định nghĩa phương thức <code>Draw()</code>, nhưng mà nó kế thừa
lớp <code>Widget</code> nên nó vẫn có trường <code>id</code> và phương thức <code>Draw()</code>, vậy nên
đoạn code trong <code>Main()</code> không bị lỗi.</p>
<p>Nếu không kế thừa lớp nào thì sao? Nó sẽ tự động được coi là kế thừa lớp
<code>object</code>, một lớp có sẵn của C#. Mục đích của việc làm như vầy là để tất
cả các lớp trong C# đều bắt nguồn từ cùng 1 lớp, nhờ vậy khi cần lưu một
đối tượng bất kỳ có thể dùng kiểu <code>object</code>.</p>
<h3 id="mức-truy-cập-khi-kế-thừa-và-từ-khóa-protected">Mức truy cập khi kế thừa và từ khóa <code>protected</code></h3>
<p>Ví dụ ở trên chỉ toàn thành viên <code>public</code>, vậy nếu dùng <code>private</code> thì sao?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id = -<span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Widget.Draw()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Click()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Button.Click&#34;</span>);
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> PrintId()
	{
		<span style="color:#75715e">// Console.WriteLine(id);
</span><span style="color:#75715e"></span>	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		<span style="color:#75715e">// Console.WriteLine(button.id);
</span><span style="color:#75715e"></span>		button.Draw(); <span style="color:#75715e">// In ra &#34;Widget.Draw()&#34;
</span><span style="color:#75715e"></span>		button.Click();
	}
}
</code></pre></div><p>Đoạn code bên trên có 2 dòng code nằm trong chú thích, bỏ chú thích dòng nào
trong đó cũng đều gây ra lỗi biên dịch. Đây là vì <code>private</code> chỉ có thể được
truy cập trong lớp chứa nó, lớp <code>Button</code> kế thừa <code>Widget</code> nhưng mà nó vẫn là
lớp bên ngoài nên không thể truy cập trường <code>id</code>.</p>
<p><code>private</code> và <code>public</code> là dạng tất cả hoặc không gì cả, chỉ dùng 2 mức truy cập
này là không đủ cho mọi trường hợp, cho nên có thêm mức truy cập khác được đưa
ra: <code>protected</code>. Thành viên có mức truy cập <code>protected</code> sẽ có thể được truy cập
ở những lớp dẫn xuất, còn những lớp khác vẫn không có quyền truy cập.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> id = -<span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Widget.Draw()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Click()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Button.Click&#34;</span>);
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> PrintId()
	{
		<span style="color:#75715e">// Lúc này không lỗi nữa vì Button kế thừa Widget
</span><span style="color:#75715e"></span>		Console.WriteLine(id);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		<span style="color:#75715e">// Nhưng mà dòng này vẫn lỗi vì Program không kế thừa Widget
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Console.WriteLine(button.id);
</span><span style="color:#75715e"></span>		button.Draw(); <span style="color:#75715e">// In ra &#34;Widget.Draw()&#34;
</span><span style="color:#75715e"></span>		button.Click();
	}
}
</code></pre></div><h3 id="gọi-đến-phương-thức-khởi-tạo-của-lớp-cơ-sở">Gọi đến phương thức khởi tạo của lớp cơ sở</h3>
<p>Khi kế thừa thì các trường cũng được đem sang (kể cả private, chỉ là
không truy cập được nó thôi chứ nó vẫn tồn tại). Khi khởi tạo đối tượng
cần phải khởi tạo luôn cho phần kế thừa được, thông qua phương thức khởi
tạo của lớp cơ sở. Cách viết giống với khi gọi tới phương thức khởi tạo
trong cùng lớp, chỉ có điều lúc này không gọi tới phương thức khởi tạo
của lớp hiện tại nữa (lúc này đang muốn gọi tới cái phương thức khởi tạo
của lớp cơ sở), cho nên không dùng <code>this</code> mà dùng một từ khóa khác: <code>base</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> name;

	<span style="color:#66d9ef">public</span> Widget(<span style="color:#66d9ef">string</span> name)
	{
		<span style="color:#66d9ef">this</span>.name = name;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;{0} is drawing&#34;</span>, name);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> text;

	<span style="color:#66d9ef">public</span> Button(<span style="color:#66d9ef">string</span> name, <span style="color:#66d9ef">string</span> labelText) : <span style="color:#66d9ef">base</span>(name)
	{
		text = labelText;
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button(<span style="color:#e6db74">&#34;btn1&#34;</span>, <span style="color:#e6db74">&#34;Click me&#34;</span>);
		button.Draw();
	}
}
</code></pre></div><h3 id="nạp-chồng-trên-nhiều-lớp">Nạp chồng trên nhiều lớp</h3>
<p>Những phương thức kế thừa được vẫn có thể nạp chồng (overload) như bình thường.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Base.Print()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> : Base
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print(<span style="color:#66d9ef">int</span> unused)
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Derived.Print(int)&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		<span style="color:#66d9ef">new</span> Derived().Print(); <span style="color:#75715e">// Gọi tới Print() kế thừa được từ Base
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">new</span> Derived().Print(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">// Gọi tới Print(int) được nạp chồng
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><h3 id="che-phương-thức-kế-thừa-được">Che phương thức kế thừa được</h3>
<p>Không chỉ dừng ở nạp chồng, C# còn cho phép định nghĩa một
phương thức hoàn toàn giống với phương thức ở lớp cơ sở.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Base.Print()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> : Base
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Derived.Print()&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Derived a = <span style="color:#66d9ef">new</span> Derived();
		a.Print(); <span style="color:#75715e">// Gọi tới Print() của Derived
</span><span style="color:#75715e"></span>		Base b = <span style="color:#66d9ef">new</span> Derived();
		b.Print(); <span style="color:#75715e">// Gọi tới Print() của Base
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><p>Đoạn chương trình trên có một vài điểm đặc biệt chưa được nói đến.
Trước hết là phép gán trong <code>Main()</code>: biến có kiểu là lớp cơ sở có
thể trỏ tới đối tượng của lớp dẫn xuất. Tiếp đó là biến kiểu gì sẽ
gọi phương thức của lớp đó: biến <code>b</code> trỏ tới đối tượng kiểu <code>Derived</code>
nhưng mà vì nó kiểu <code>Base</code> nên vẫn gọi tới phương thức của <code>Base</code>.
Trường hợp này gọi là phương thức <code>Print()</code> của <code>Derived</code> đã giấu (hide)
phương thức <code>Print()</code> của <code>Base</code> đi. Nói như vậy là vì khi sử dụng lớp
<code>Derived</code> mới không dùng được <code>Print()</code> của <code>Base</code>, khi khai báo biến
kiểu <code>Base</code> là lại dùng được tiếp, không bị giấu nữa, chỉ khi dùng
<code>Derived</code> thì <code>Print()</code> của <code>Base</code> mới bị giấu đi.</p>
<h3 id="gọi-phương-thức-ở-lớp-cơ-sở-lại-gặp-base">Gọi phương thức ở lớp cơ sở, lại gặp <code>base</code></h3>
<p>Lại nói một chút về việc tránh lặp code. Rất nhiều lúc lớp dẫn xuất
cần gọi tới phương thức ở lớp cơ sở để tránh lặp code, C# dùng từ khóa
<code>base</code> cho mục đích này, cũng một từ khóa dùng với 2 nghĩa gần nhau như
<code>this</code> (<code>this</code> có 2 chức năng: dùng như tên phương thức khởi tạo của lớp
hiện tại và dùng để chỉ đến đối tượng gọi phương thức, <code>base</code>cũng vậy: dùng
như tên phương thức khởi tạo của lớp cơ sở và dùng để trỏ tới phần kế thừa
từ lớp cơ sở).</p>
<p>Ví dụ với đoạn code bên dưới:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ chữ bên trong&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TextBox</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
		Console.WriteLine(<span style="color:#e6db74">&#34;Tô màu phần bên trong hình chữ nhật&#34;</span>);
	}
}
</code></pre></div><p>Phần vẽ viền là phần chung và bị lặp ở từng lớp kế thừa nó. Để
giải quyết vấn đề này có thể viết lại bằng cách dùng <code>base</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ chữ bên trong&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TextBox</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Tô màu phần bên trong hình chữ nhật&#34;</span>);
	}
}
</code></pre></div><h3 id="nạp-đè">Nạp đè</h3>
<p>Mọi chuyện đều vẫn rất tốt, cho tới khi kiểu của đối tượng không
còn rõ ràng nữa.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ chữ bên trong&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TextBox</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Tô màu phần bên trong hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
	<span style="color:#66d9ef">private</span> Widget[] widgets;

	<span style="color:#66d9ef">public</span> Window(Widget[] widgets)
	{
		<span style="color:#66d9ef">this</span>.widgets = widgets;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">foreach</span> (Widget widget <span style="color:#66d9ef">in</span> widgets)
		{
			widget.Draw(); <span style="color:#75715e">// ???
</span><span style="color:#75715e"></span>		}
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		TextBox textBox = <span style="color:#66d9ef">new</span> TextBox();
		Window window = <span style="color:#66d9ef">new</span> Window(<span style="color:#66d9ef">new</span> Widget[] { button, textBox });
		window.Draw();
	}
}
</code></pre></div><p>Chú ý dòng có chú thích <code>// ???</code>. Bởi vì biến <code>widget</code> có kiểu là
<code>Widget</code> nên khi nó chỉ tới một <code>Button</code> thì nó vẫn chỉ vẽ viền rồi
thôi, trong khi đúng ra nó cần phải vẽ phần chữ bên trong nữa. Vấn
đề này không thể sửa bằng cách đổi kiểu của mảng <code>widgets</code> thành
<code>Button[]</code> được, biết đâu có cái widget nào đó là <code>TextBox</code> chứ
không phải Button rồi sao?</p>
<p>Vì sao nó lại ra như vầy? Hành vi quan sát được từ đoạn code này
hoàn toàn giống với phần mô tả về che phương thức được viết trước
đó. Vậy là tại mình chọn cách che đi phương thức của lớp cơ sở.
Muốn đoạn code trên chạy đúng thì phương thức ở lớp dẫn xuất phải
thay thế luôn phương thức ở lớp cơ sở chứ không chỉ che đi.</p>
<p>Việc thay thế một phương thức kế thừa từ lớp cơ sở như vậy gọi là
nạp đè (override). Để làm vậy được thì trước hết cần khai báo
phương thức là <code>virtual</code> (ảo), chỉ có <code>virtual</code> mới nạp đè (override)
được. Sau đó ở mỗi lớp dẫn xuất phải thêm từ khóa <code>override</code> để thể
hiện là mình muốn nạp đè thay vì che phương thức cũ đi.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ chữ bên trong&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TextBox</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Tô màu phần bên trong hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
	<span style="color:#66d9ef">private</span> Widget[] widgets;

	<span style="color:#66d9ef">public</span> Window(Widget[] widgets)
	{
		<span style="color:#66d9ef">this</span>.widgets = widgets;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">foreach</span> (Widget widget <span style="color:#66d9ef">in</span> widgets)
		{
			widget.Draw(); <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span>		}
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		TextBox textBox = <span style="color:#66d9ef">new</span> TextBox();
		Window window = <span style="color:#66d9ef">new</span> Window(<span style="color:#66d9ef">new</span> Widget[] { button, textBox });
		window.Draw();
	}
}
</code></pre></div><p>Lúc này chương trình mới chạy đúng như mong muốn.</p>
<h3 id="che-phương-thức-ảo">Che phương thức ảo</h3>
<p>Nếu bỏ qua từ khóa <code>override</code> chương trình vẫn chạy, nhưng chạy sai.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Draw()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ viền hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Button</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Vẽ chữ bên trong&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TextBox</span> : Widget
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">base</span>.Draw();
		Console.WriteLine(<span style="color:#e6db74">&#34;Tô màu phần bên trong hình chữ nhật&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window</span>
{
	<span style="color:#66d9ef">private</span> Widget[] widgets;

	<span style="color:#66d9ef">public</span> Window(Widget[] widgets)
	{
		<span style="color:#66d9ef">this</span>.widgets = widgets;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
	{
		<span style="color:#66d9ef">foreach</span> (Widget widget <span style="color:#66d9ef">in</span> widgets)
		{
			widget.Draw();
		}
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		Button button = <span style="color:#66d9ef">new</span> Button();
		TextBox textBox = <span style="color:#66d9ef">new</span> TextBox();
		Window window = <span style="color:#66d9ef">new</span> Window(<span style="color:#66d9ef">new</span> Widget[] { button, textBox });
		window.Draw();
	}
}
</code></pre></div><p>Khi không viết <code>override</code> thì chuyện gì xảy ra mà nó lại sai? C# che
phương thức! Nếu để ý kỹ sẽ thấy khi bỏ trống sẽ có một warning cho
dòng đó. Có 2 lựa chọn khi định nghĩa phương thức giống y phương thức
ở lớp cơ sở: nạp đè hoặc che phương thức cơ sở đi. Để chọn giữa 2 cái
này C# có 2 từ khóa tương ứng: <code>override</code> và <code>new</code> (vẫn như cũ, cùng
một từ khóa bị đem ra dùng cho nhiều mục đích khác nhau, <code>new</code> trong
trường hợp này không phải để tạo đối tượng). Khi bỏ trống thì trình
biên dịch sẽ coi như mình chọn dùng <code>new</code> thay vì <code>override</code>.</p>
<p>Dưới góc nhìn cá nhân thì che phương thức là một tính năng của C# mà
không ai cần tới, đã vậy còn gây ra ảnh hưởng xấu tới code. Cho nên nếu
viết phương thức cứ cho tất cả tụi nó thành <code>virtual</code> hết khi định nghĩa
phương thức trùng tên trong lớp dẫn xuất thì cứ <code>override</code> hết đi.</p>
<h3 id="abstract"><code>abstract</code>???</h3>
<p>TODO: Write this?</p>
<h3 id="giao-diện-interface-và-đa-kế-thừa">Giao diện (interface) và đa kế thừa</h3>
<p>Lớp kế thừa lớp để thể hiện mối quan hệ &ldquo;is-a&rdquo;, có nghĩa là đối tượng
của lớp dẫn xuất cũng có thể xài y như đối tượng của lớp cơ sở. Tuy
nhiên hạn chế của nó rất lớn vì khó kiếm được mối quan hệ thỏa mãn
điều kiện trên.</p>
<p>Bởi vì mối quan hệ này khó đạt được quá, nên người ta tăng tính trừu
tượng của chương trình bằng cách khác: thể hiện khả năng thay vì thể
hiện mối quan hệ kế thừa. C# hỗ trợ làm việc này bằng giao diện, với
từ khóa để khai báo là <code>interface</code>. Đừng nhầm lẫn nó với giao diện
người dùng, giao diện có nghĩa là mặt tiếp xúc giữa 2 đơn vị, không
phải lúc nào 2 đơn vị này cũng là máy tính và con người, xem đoạn
code dưới này:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Printable</span>
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print()
	{
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorld</span> : Printable
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntNumber</span> : Printable
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span>;
	<span style="color:#66d9ef">public</span> IntNumber(<span style="color:#66d9ef">int</span> val)
	{
		<span style="color:#66d9ef">value</span> = val;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#66d9ef">value</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> PrintObject(Printable obj)
	{
		obj.Print();
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		PrintObject(<span style="color:#66d9ef">new</span> HelloWorld());
		PrintObject(<span style="color:#66d9ef">new</span> IntNumber(<span style="color:#ae81ff">123</span>));
	}
}
</code></pre></div><p>Trong đoạn code trên, <code>PrintObject()</code> không cần biết đối tượng được
truyền vào là cái gì, nó chỉ quan tâm một việc: có <code>Print()</code> được hay
không, miễn là được thì nó đều chấp nhận. <code>PrintObject()</code> tương tác với
đối tượng thuộc kiểu <code>HelloWorld</code> hoặc <code>IntNumber</code> thông qua <code>Print()</code>,
cho nên cái phương thức <code>Print()</code> này chính là cái giao diện (chỗ 2 bên
tiếp xúc nhau). Đây chỉ là ví dụ cho cái khái niệm &ldquo;giao diện&rdquo; thôi, còn
cách viết trong C# thì cần đọc tiếp bên dưới.</p>
<p>Ở đoạn code trên, <code>Printable</code> được dùng như một tên lớp, nó thể hiện vấn
đề khi đọc code: từ trước tới giờ tên lớp đều là danh từ, nhưng bây giờ
nó lại không phải (printable là tính từ). Để giữ cho tên lớp đều là danh
từ, C# thêm từ khóa <code>interface</code> để khai báo giao diện. Cách viết cũng tương
tự như khi viết một class, nhưng có những điểm đặc biệt này:</p>
<ul>
<li>Không cần viết phần thân phương thức. Giao diện chỉ dùng để mô tả coi nó
có thể làm gì, chứ không phải để định nghĩa nó làm như thế nào.</li>
<li>Không cần viết <code>public</code>. Đã là chỗ tiếp xúc của 2 bên thì làm sao có thể
không công khai được, nên tất cả trong giao diện đều mặc định là public.</li>
</ul>
<p>Khi mà một lớp muốn thể hiện là mình có thể đáp ứng được yêu cầu của một cái
giao diện, lớp đó sẽ thực thi (&ldquo;implement&rdquo;) giao diện đó. Cú pháp giống với
kế thừa, chỉ khác là xài tên giao diện thay vì tên lớp. Lớp thực thi một giao
diện nào đó sẽ được gọi là implementation. Trong phần định nghĩa của lớp sẽ
có một phương thức có cùng dấu hiệu với phương thức được mô tả trong <code>interface</code>.</p>
<p>Chương trình bên trên viết lại bằng <code>interface</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;

<span style="color:#66d9ef">interface</span> IPrintable
{
	<span style="color:#66d9ef">void</span> Print();
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorld</span> : IPrintable
{
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntNumber</span> : IPrintable
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span>;
	<span style="color:#66d9ef">public</span> IntNumber(<span style="color:#66d9ef">int</span> val)
	{
		<span style="color:#66d9ef">value</span> = val;
	}
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Print()
	{
		Console.WriteLine(<span style="color:#66d9ef">value</span>);
	}
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
{
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> PrintObject(IPrintable obj)
	{
		obj.Print();
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
	{
		PrintObject(<span style="color:#66d9ef">new</span> HelloWorld());
		PrintObject(<span style="color:#66d9ef">new</span> IntNumber(<span style="color:#ae81ff">123</span>));
	}
}
</code></pre></div><p>TODO: Write about Explicit interface implementation?</p>
<h2 id="chi-tiết-về-phương-thức">Chi tiết về phương thức</h2>
<p>callback, predicate, lambda
out, ref
operator overloading</p>
<h2 id="misc">Misc</h2>
<p>Namespace</p>


        </div></body>
</html>
